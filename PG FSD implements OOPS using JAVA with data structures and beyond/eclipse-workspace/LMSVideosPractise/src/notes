Multitasking - multiple programs running parallelly - it is an illusion shows that it runs parallelly
but processors run only one at a time - so called Multitasking using process - but the problem here is 
when we divide tasks into process, each having its own memory - so when we move from youtube to another app
context switching happens - switch from one process to other and it has to remember where it stops to get back to the same 
portion it stopped earlier - they are heavy weighted, theu contain their own memory and not share any memory cross - not  as fast as threading

Multitasking using threads - instead of creating multiple processes why not create multiple subprocess inside a process 
multiple subprocesses inside one single process 
all of these subprocess shared single memory which is part of that process, they do not have independent memory of own 
so, even if one thread got stopped the other thread runs independently 

concept of multithreading or multitasking using process is running multiple programs at the same time or concurrent processing or paralle corssing

Threads:light weight process - sub process which executes as a seperate program - which is ued to execute multiple tasks simultaneously 

thread will have shared memory vs process will have individual memory 
threads run inside a process
execution is faster
memory intensive 

how to run programs parallelly? 

example - when you take a program and lets say there are 4 or 5 functions in it which we can call tasks also 
each of these tasks can be executed simultaneously using threading concept 

Thread life cycle:
new 
runnable - ready to run
waiting/sleeping/blocking - it is just waiting  
running - actually when it runs
terminated 

Thread priority:
sets by default 
or,
public final void setPriority(int newPriority) method 
getPriority() is to get the priority value 

min priority = 0
max = 10
default = 5


Demon thread:
service provider threads 
to just provide services to the user threads 
priority level - low
examples are - garbage collection, finalizer 


Thread scheduling and sleeping: its all about,
how you think JVM should know which thread to run first?
How do i identify the next thread to run?
1. Deciding which one to run first
2. Arranging in a way so that i can pick thread
Scheduling is a set of programs or algorithms using which the JVM decides which one to pick first 
1. pre-emptive - before a thread finishes, it is given to another
2. time slicing - every thread will be given some time after that JVM stores all context and go to next thread 

how to put a thread to sleep state for some time?
Advantage is that JVM can be given to somebody else
overloaded methods, 
public static void sleep(long milisec)
throws InterruptedException
public static void sleep(long milisec, int nanos)
throws InterruptedException


Thread synchronization:
how to ensure the data is not messed up when multiple threads are accessing common resource  
1. To prevent thread interference 
2. To prevent consistency problem 

Syncorinized method: 
when it is invoked, it locks the object and release it once the task is completed
synchronized void printing(int n, String s)  // until printing is done it wont let other object to access it 
unless it is finished it wont give control to others 

Static Synchronized method:
it will lock the class not the object 
synchonized sttatic void printing(int numbers) 

Inter thread communication:
- also called cooperation
-synchronized threads communicate with each other - like wait(), notify(), notifyAll()

Interrupt a thread: stopping that guy in the middle
- JVM can be given to other thread only when thread goes to sleep state 
When interrupt() on a thread in sleeping or waiting state, breaks out the sleeping or waiting state and throws InterruptedException 
It interrupts a thread from sleeping or waiting state 
public void interrupt()
public static boolean interrupted()
public boolean isInterrupted() - it gives true for non sleeping threads but it never interrupts that thread

Wrapper classes:
int, float, double - are primitive datatypes
wrapper classes can turn the datatypes into objects 
also get many functions tied to it
primitive datatypes - wrapper class
boolean - Boolean
char - Character
byte - Byte
short - Short
int - Integer
long - Long
float - Float
double - Double 

char a = 'a';
Integer b = new Integer(132); // it is a wrapper object rather than primitive datatype


Autoboxing - converting primitives into object datatypes
Unboxing - converting datatypes into primitives 
Integer x = new Integer(540);
int a = x;






